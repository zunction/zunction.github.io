<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>Zhangsheng  Lai | Reading Casper CBC proofs - Part 2</title>
<meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design.
">

<!-- Open Graph -->


<!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css" integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css" integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet" href="https://gitcdn.xyz/repo/jwarby/jekyll-pygments-themes/master/github.css" />

<!-- Styles -->

<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üêî</text></svg>">

<link rel="stylesheet" href="/assets/css/main.css">

<link rel="canonical" href="/blog/2021/reading-casper-cbc-proofs-p2/">

<!-- JQuery -->
<!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>


<!-- Theming-->

  <script src="/assets/js/theme.js"></script>
  <!-- Load DarkMode JS -->
<script src="/assets/js/dark_mode.js"></script>



  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-73850109-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'UA-73850109-1');
  </script>




    
<!-- MathJax -->
<script type="text/javascript">
  window.MathJax = {
    tex: {
      tags: 'ams'
    }
  };
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>


  </head>

  <body class="fixed-top-nav ">

    <!-- Header -->

    <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      
      <a class="navbar-brand title font-weight-lighter" href="/">
       <span class="font-weight-bold">Zhangsheng</span>   Lai
      </a>
      
      <!-- Navbar Toggle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">
              about
              
            </a>
          </li>
          
          <!-- Blog -->
          <li class="nav-item active">
            <a class="nav-link" href="/blog/">
              blog
              
            </a>
          </li>
          
          <!-- Other pages -->
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/projects/">
                projects
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/publications/">
                publications
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/teaching/">
                teaching
                
              </a>
          </li>
          
          
          
            <div class = "toggle-container">
              <a id = "light-toggle">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
              </a>
            </div>
          
        </ul>
      </div>
    </div>
  </nav>

</header>


    <!-- Content -->

    <div class="container mt-5">
      

<div class="post">

  <header class="post-header">
    <h1 class="post-title">Reading Casper CBC proofs - Part 2</h1>
    <p class="post-meta">May 27, 2021</p>
  </header>

  <article class="post-content">
    <p>We continue from where we left off earlier in <a href="https://zunction.github.io/blog/2021/reading-casper-cbc-proofs/">Part 1</a> and continue reading the <a href="https://github.com/runtimeverification/casper-cbc-proofs/blob/master/CBC/Binary.v"><code class="language-plaintext highlighter-rouge">Binary.v</code></a> code.
The code which we are covering today starts working on \(\S 2.2\) of the paper.</p>

<p><strong>Some paper definitions.</strong> We start by going through what are protocol states and messages.
As protocol states and messages both change over time as new blocks are mined or validated, a time step \(n\) is used to index the time. 
For \(n = 0\), the protocol states \(\Sigma\) starts off empty:</p>

\[\Sigma^0 := \{\emptyset\}\]

<p>With this declared, we can then talk about messages, which are triples formed from consensus value \(\mathcal{C}\), validators \(\mathcal{V}\) and protocol states a time step \(\Sigma^n\),</p>

\[M^n := \{m \in \mathcal{C} \times \mathcal{V} \times \Sigma^n \mid Estimate(m) \in \mathcal{E}(Justification(m)) \}\]

<p>such that the projection of the consensus value denoted by \(Estimate(m)\) of each message in \(M^n\) is in the set of consensus values \(\mathcal{E}(Justification(m))\).
Let‚Äôs go into details of the definition of \(M^n\).
As messages are triples, it comes along with projection functions (the lack of the superscript \(n\) for \(M\) will be explained later) which we went through the code for it in Part 1:</p>

\[Estimate: M \to \mathcal{C}\]

\[Sender: M \to \mathcal{V}\]

\[Justification: M \to \Sigma\]

<p>Using the binary consensus as an example, we will have for any \(m \in M^0\), \(Estimate(m)\) will be either \(0\) or \(1\) and \(Justification(m) = \emptyset\).
Next the \(\mathcal{E} : \Sigma \to \mathcal{P}(\mathcal{C})\backslash \emptyset\) is an estimator function (different from the \(Estimate\) projection function) which maps a protocol state to a non-empty subset of possible consensus value, denoted by \(\mathcal{P}(\mathcal{C})\backslash \emptyset\).
Thus if \(M^0\) is non-empty, it would require \(\mathcal{E}\) to map the empty set to a set which contains \(Estimate(m)\).</p>

<p><strong>Upshot</strong>: <em>a triple is a message only if its consensus value is one of the possible values evaluated by \(\mathcal{E}\) on the protocol state of the triple.</em></p>

<p>Now we can talk about what protocol states are when \(n &gt;0\).</p>

\[\Sigma^n := \{\sigma \in \mathcal{P}_{finite}(M^{n-1}) \mid m \in \sigma \implies Justification(m) \subseteq \sigma\} ~~ \text{for } n &gt;0\]

<p>Breaking down the definition, a protocol state \(\sigma \in \Sigma^n\) is a finite subset of \(M^{n-1}\) such that \(m \in \sigma\) when the protocol state of \(m\) (\(Justification(m)\)) is a subset of the protocol state \(\sigma\).
This means not every subset of \(M^{n-1}\) is a protocol state.
A subset of \(M^{n-1}\) is a protocol state when the protocol state of each message in the subset is contained in the subset.</p>

<p>Let‚Äôs work out an example: suppose \(\mathcal{E}(\emptyset) = \{0,1\}\)<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> and assuming two validators \(v_1, v_2 \in \mathcal{V}\), then we can have one possible \(M^0\) like this:</p>

\[M^0 = \{(0,v_1,\emptyset), (1,v_2,\emptyset)\}\]

\[\mathcal{P}_{finite}(M^0)= \mathcal{P}(M^0)= \{ \{\emptyset\}, \{(0,v_1,\emptyset)\}, \{(1,v_2,\emptyset)\}, \{(0,v_1,\emptyset), (1,v_2,\emptyset)\} \}\]

<p>and we see that</p>

\[\{(0,v_1,\emptyset)\}, \{(1,v_2,\emptyset)\}, \{(0,v_1,\emptyset), (1,v_2,\emptyset)\} \in \Sigma^1\]

<p>since for each \(\sigma \in \Sigma^1\) and \(m \in \sigma\) above, \(Justification(m) = \emptyset \in \sigma\) trivially.
An example of a nontrivial protocol state is:</p>

\[\sigma := \{(0,v_1,\{(1,v_2,\emptyset)\}), (1,v_2,\emptyset)\}\]

<p>the justification of the message \((0,v_1,\{(1,v_2,\emptyset)\})\) is \(\{(1,v_2,\emptyset)\} \subseteq \sigma\)</p>

<p><strong>Upshot</strong>: <em>an element \(\sigma\) in \({P}_{finite}(M^{n-1})\) (which is a subset \(M^{n-1}\)) is a protocol state if the protocol state of each message in \(\sigma\) is a subset \(\sigma\)</em></p>

<p>Lastly, the definition of protocol states and messages are completed by</p>

\[M := \bigcup_{i=0}^{\infty}M^i\]

\[\Sigma := \bigcup_{i=0}^{\infty}\Sigma^i\]

<p>thus the notations without the superscript to denote the time is simply the union of all of them.</p>

<p>At this point, some thoughts that I have is about the representation of messages in Coq. 
The definitions in <code class="language-plaintext highlighter-rouge">Binary.v</code> which we went through previously (at least for now) does not enforce that the consensus value of a message be an element of the possible consensus value given by the estimator \(\mathcal{E}\).
It is also mentioned in the paper that the domain of the estimator is yet to be defined, thus perhaps this constrain might be addressed later.</p>

<p>With the definitions established and understood, we are ready to head over to the code side.</p>

<h4 id="to-the-code">To the code</h4>

<p>Recall that protocol states are defined as <code class="language-plaintext highlighter-rouge">justification_type</code> which is a list of hashes <code class="language-plaintext highlighter-rouge">H</code>.</p>

<p>Using <a href="https://coq.inria.fr/library/Coq.Lists.ListSet.html#set"><code class="language-plaintext highlighter-rouge">set</code></a>, which is a function which takes a type to a list of its type, i.e.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">fun</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kr">Type</span><span class="w">
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">state</code>s are list of <code class="language-plaintext highlighter-rouge">message</code>s, and we have the trivial state <code class="language-plaintext highlighter-rouge">state0</code> to be the empty list.
<a href="https://coq.inria.fr/refman/language/core/assumptions.html?highlight=parameters#coq:cmd.Parameters"><code class="language-plaintext highlighter-rouge">Parameter</code></a> declarations in Coq are used to declare an abstract object of the given type.
Below, the parameter <code class="language-plaintext highlighter-rouge">about_state</code> declares that we assume that we have a proof that <code class="language-plaintext highlighter-rouge">state</code> satisfies the strictly comparable property.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">state</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">set</span><span class="w"> </span><span class="no">message</span><span class="pi">.</span><span class="w">

</span><span class="k">Definition</span><span class="w"> </span><span class="no">state0</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">state</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="o">[].</span><span class="w">  

</span><span class="no">Parameter</span><span class="w"> </span><span class="no">about_state</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">StrictlyComparable</span><span class="w"> </span><span class="no">state</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>To establish that two protocol states \(s1, s2\) are equal, we need to construct a proof for the proposition <code class="language-plaintext highlighter-rouge">state_eq s1 s2</code> which checks that each state is the inclusion of the other.
The <code class="language-plaintext highlighter-rouge">state_union</code> function takes two protocol states and returns a union. 
This process is not similar to the concatenation two list of messages as a set which in this case is represented by a list of messages, can only have distinct elements.
Thus the <code class="language-plaintext highlighter-rouge">compare_eq_dec</code> is a proof that the comparison function <code class="language-plaintext highlighter-rouge">compare</code> has <a href="https://ncatlab.org/nlab/show/decidable+equality#:~:text=1.-,Definitions,either%20equal%20or%20not%20equal.&amp;text=More%20generally%2C%20X%20has%20stable,they%20are%20not%20not%20equal.">decidable equality</a> and is used in the <code class="language-plaintext highlighter-rouge">state_union</code> function.
The last line is a lemma which states an easy result that union of states is commutative.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">state_eq</span><span class="w"> </span><span class="o">(</span><span class="no">s1</span><span class="w"> </span><span class="no">s2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">state</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">incl</span><span class="w"> </span><span class="no">s1</span><span class="w"> </span><span class="no">s2</span><span class="w"> </span><span class="o">/\</span><span class="w"> </span><span class="no">incl</span><span class="w"> </span><span class="no">s2</span><span class="w"> </span><span class="no">s1</span><span class="pi">.</span><span class="w">
</span><span class="k">Definition</span><span class="w"> </span><span class="no">state_union</span><span class="w"> </span><span class="o">(</span><span class="no">s1</span><span class="w"> </span><span class="no">s2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">state</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">state</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">set_union</span><span class="w"> </span><span class="no">compare_eq_dec</span><span class="w"> </span><span class="no">s1</span><span class="w"> </span><span class="no">s2</span><span class="pi">.</span><span class="w">
</span><span class="k">Lemma</span><span class="w"> </span><span class="no">state_union_comm</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">s1</span><span class="w"> </span><span class="no">s2</span><span class="o">,</span><span class="w"> </span><span class="no">state_eq</span><span class="w"> </span><span class="o">(</span><span class="no">state_union</span><span class="w"> </span><span class="no">s1</span><span class="w"> </span><span class="no">s2</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">state_union</span><span class="w"> </span><span class="no">s2</span><span class="w"> </span><span class="no">s1</span><span class="o">).</span><span class="w">
</span></code></pre></div></div>

<p>The next 40 plus lines is a haemorrhage of definitions, beginning with</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">observed</span><span class="w"> </span><span class="o">(</span><span class="no">sigma</span><span class="p">:</span><span class="no">state</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">V</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">  </span><span class="no">set_map</span><span class="w"> </span><span class="no">compare_eq_dec</span><span class="w"> </span><span class="no">sender</span><span class="w"> </span><span class="no">sigma</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>The function <code class="language-plaintext highlighter-rouge">observed</code> takes in a protocol state (list of messages) and extracts a list of validators in each message using <a href="https://coq.inria.fr/library/Coq.Lists.ListSet.html#set_map"><code class="language-plaintext highlighter-rouge">set_map</code></a> and <code class="language-plaintext highlighter-rouge">sender</code> function defined earlier (cf. Part 1).
Although the explicit form of <code class="language-plaintext highlighter-rouge">V</code> is not described, the use of <code class="language-plaintext highlighter-rouge">set_map</code> suggests that we can take <code class="language-plaintext highlighter-rouge">V</code> to be a set of elements, perhaps strings which represent the validator‚Äôs name.</p>

<p>Next two parameters are declared:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Parameters</span><span class="w"> </span><span class="o">(</span><span class="no">hash</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">message</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">H</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">hash_injective</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Inj</span><span class="w"> </span><span class="no">eq</span><span class="w"> </span><span class="no">eq</span><span class="w"> </span><span class="no">hash</span><span class="o">).</span><span class="w"> 
</span></code></pre></div></div>

<p>The next function <code class="language-plaintext highlighter-rouge">later</code> filters for messages in <code class="language-plaintext highlighter-rouge">sigma</code> such that the protocol state of every message, which we shall subsequently call it the <em>justification of the message</em>, in <code class="language-plaintext highlighter-rouge">sigma</code> contains the given message <code class="language-plaintext highlighter-rouge">msg</code>.
Recall early we saw that \(\Sigma^n\) is formed from \(M^{n-1}\).
Thus if <code class="language-plaintext highlighter-rouge">msg</code> is in the justification of <code class="language-plaintext highlighter-rouge">msg'</code> this implies that <code class="language-plaintext highlighter-rouge">msg'</code> is a later message compared to <code class="language-plaintext highlighter-rouge">msg</code>.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">later</span><span class="w"> </span><span class="o">(</span><span class="no">msg</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">message</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">sigma</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">state</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">message</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
    </span><span class="no">filter</span><span class="w"> </span><span class="o">(</span><span class="kr">fun</span><span class="w"> </span><span class="no">msg'</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">inb</span><span class="w"> </span><span class="no">compare_eq_dec</span><span class="w"> </span><span class="o">(</span><span class="no">hash</span><span class="w"> </span><span class="no">msg</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">justification</span><span class="w"> </span><span class="no">msg'</span><span class="o">))</span><span class="w"> </span><span class="no">sigma</span><span class="pi">.</span><span class="w"> 
</span></code></pre></div></div>

<p><strong>Upshot</strong> : <code class="language-plaintext highlighter-rouge">later</code> <em>returns messages from a list of message which occurs later than the given message.</em></p>

<p>In the function <code class="language-plaintext highlighter-rouge">from_sender</code>, it filters for messages in <code class="language-plaintext highlighter-rouge">sigma</code> such that the validator of the message is the given validator <code class="language-plaintext highlighter-rouge">v</code>,</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">from_sender</span><span class="w"> </span><span class="o">(</span><span class="no">v</span><span class="p">:</span><span class="no">V</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">sigma</span><span class="p">:</span><span class="no">state</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">message</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
    </span><span class="no">filter</span><span class="w"> </span><span class="o">(</span><span class="kr">fun</span><span class="w"> </span><span class="no">msg'</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">compareb</span><span class="w"> </span><span class="o">(</span><span class="no">sender</span><span class="w"> </span><span class="no">msg'</span><span class="o">)</span><span class="w"> </span><span class="no">v</span><span class="o">)</span><span class="w"> </span><span class="no">sigma</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>
<p>Lastly, <code class="language-plaintext highlighter-rouge">later_from</code> is the composition of <code class="language-plaintext highlighter-rouge">later</code> and <code class="language-plaintext highlighter-rouge">from_sender</code>, which filters for messages in <code class="language-plaintext highlighter-rouge">sigma</code> such that its justification contains the given <code class="language-plaintext highlighter-rouge">msg</code> and is validated by validator <code class="language-plaintext highlighter-rouge">v</code>.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">later_from</span><span class="w"> </span><span class="o">(</span><span class="no">msg</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">message</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">v</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">V</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">sigma</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">state</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">message</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
    </span><span class="no">filter</span><span class="w"> </span><span class="o">(</span><span class="kr">fun</span><span class="w"> </span><span class="no">msg'</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">(</span><span class="no">inb</span><span class="w"> </span><span class="no">compare_eq_dec</span><span class="w"> </span><span class="o">(</span><span class="no">hash</span><span class="w"> </span><span class="no">msg</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">justification</span><span class="w"> </span><span class="no">msg'</span><span class="o">))</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">(</span><span class="no">compareb</span><span class="w"> </span><span class="o">(</span><span class="no">sender</span><span class="w"> </span><span class="no">msg'</span><span class="o">)</span><span class="w"> </span><span class="no">v</span><span class="o">))</span><span class="w"> </span><span class="no">sigma</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p><strong>Upshot</strong> : <code class="language-plaintext highlighter-rouge">later_from</code> <em>returns messages by the given validator, from a list of messages which occurs later than the given message.</em></p>

<p>Just a though, is the observation <code class="language-plaintext highlighter-rouge">obs</code> stated below true?</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Lemma</span><span class="w"> </span><span class="no">obs</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="o">(</span><span class="no">msg</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">message</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">v</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">V</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">sigma</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">state</span><span class="o">),</span><span class="w"> 
  </span><span class="no">state_eq</span><span class="w"> </span><span class="o">(</span><span class="no">later_from</span><span class="w"> </span><span class="no">msg</span><span class="w"> </span><span class="no">v</span><span class="w"> </span><span class="no">sigma</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">from_sender</span><span class="w"> </span><span class="no">v</span><span class="w"> </span><span class="o">(</span><span class="no">later</span><span class="w"> </span><span class="no">msg</span><span class="w"> </span><span class="no">sigma</span><span class="o">)).</span><span class="w">
</span></code></pre></div></div>

<p>Leaving this as an exercise during my free time~.</p>

<p>The next definition is a boolean predicate which tests if a given list is the trivial empty list, defined to be used in <code class="language-plaintext highlighter-rouge">latest_messages</code>.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">is_nil_fn</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="p">:</span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">l</span><span class="p">:</span><span class="no">list</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">bool</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">match</span><span class="w"> </span><span class="no">l</span><span class="w"> </span><span class="kp">with</span><span class="w">
    </span><span class="o">|</span><span class="w"> </span><span class="no">nil</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">true</span><span class="w">
    </span><span class="o">|</span><span class="w"> </span><span class="p">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">false</span><span class="w">
  </span><span class="kr">end</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>In <code class="language-plaintext highlighter-rouge">latest_messages</code>, what is does is that over a list of messages by validator <code class="language-plaintext highlighter-rouge">v</code>, it filters for those messages that is <strong>not</strong> contained in another message‚Äôs justification by the same validator <code class="language-plaintext highlighter-rouge">v</code>.
A message \(m_1\) can only be contained in the justification of another message \(m_2\) iff \(m_1\) is earlier then \(m_2\)
Thus for a message to be not contained in the justification the another messages in a list of messages, it needs to be the latest, and hence the name of the function.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">latest_messages</span><span class="w"> </span><span class="o">(</span><span class="no">sigma</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">state</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">V</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">message</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
    </span><span class="kr">fun</span><span class="w"> </span><span class="no">v</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">filter</span><span class="w"> </span><span class="o">(</span><span class="kr">fun</span><span class="w"> </span><span class="no">msg</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">is_nil_fn</span><span class="w"> </span><span class="o">(</span><span class="no">later_from</span><span class="w"> </span><span class="no">msg</span><span class="w"> </span><span class="no">v</span><span class="w"> </span><span class="no">sigma</span><span class="o">))</span><span class="w"> </span><span class="o">(</span><span class="no">from_sender</span><span class="w"> </span><span class="no">v</span><span class="w"> </span><span class="no">sigma</span><span class="o">).</span><span class="w">
</span></code></pre></div></div>

<p><strong>Upshot</strong>: <code class="language-plaintext highlighter-rouge">latest_messages</code> <em>literally returns the latest messages by the given validator.</em></p>

<p>What we have next is the statement <code class="language-plaintext highlighter-rouge">latest_messages_driven</code> that says that given an estimator  <code class="language-plaintext highlighter-rouge">estimator: state -&gt; C -&gt; Prop</code>, there exists a validator <code class="language-plaintext highlighter-rouge">validator: (V -&gt; list message) -&gt; C -&gt; Prop</code> such that for all protocol states and consensus values <code class="language-plaintext highlighter-rouge">estimator sigma c</code> is inhabited iff <code class="language-plaintext highlighter-rouge">validator (latest_messages sigma) c</code> is inhabited, i.e. both the estimator and validator are in agreement given any protocol state and consensus value.
The <code class="language-plaintext highlighter-rouge">estimator</code> is referring to \(\mathcal{E}\) which we saw above and <code class="language-plaintext highlighter-rouge">validator</code> can be thought of as a validator which makes use of his latest messages to decide on the consensus value.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">latest_messages_driven</span><span class="w"> </span><span class="o">(</span><span class="no">estimator</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">state</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">C</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kr">Prop</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Prop</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
    </span><span class="kp">exists</span><span class="w"> </span><span class="no">validator</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="o">(</span><span class="no">V</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">message</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">C</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kr">Prop</span><span class="o">,</span><span class="w">
      </span><span class="kr">forall</span><span class="w"> </span><span class="no">sigma</span><span class="w"> </span><span class="no">c</span><span class="o">,</span><span class="w"> </span><span class="no">estimator</span><span class="w"> </span><span class="no">sigma</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="o">&lt;-&gt;</span><span class="w"> </span><span class="no">validator</span><span class="w"> </span><span class="o">(</span><span class="no">latest_messages</span><span class="w"> </span><span class="no">sigma</span><span class="o">)</span><span class="w"> </span><span class="no">c</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p><strong>Upshot</strong>: <code class="language-plaintext highlighter-rouge">latest_messages_driven</code> <em>says that there is a validator with knowledge of the latest messages which is consistent with the estimator</em></p>

<p>The following <code class="language-plaintext highlighter-rouge">latest_estimates</code> function provides another way to decide on possible consensus values.
Instead of using the latest messages, it extracts out the consensus component (which we shall call it by the <em>estimate of the message</em>) of those latest message and uses it to decide on the consensus value, and this function is applied in the definition of <code class="language-plaintext highlighter-rouge">latest_estimates_driven</code></p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">latest_estimates</span><span class="w"> </span><span class="o">(</span><span class="no">sigma</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">state</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">V</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">C</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
    </span><span class="kr">fun</span><span class="w"> </span><span class="no">v</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">set_map</span><span class="w"> </span><span class="no">compare_eq_dec</span><span class="w"> </span><span class="no">estimate</span><span class="w"> </span><span class="o">(</span><span class="no">latest_messages</span><span class="w"> </span><span class="no">sigma</span><span class="w"> </span><span class="no">v</span><span class="o">).</span><span class="w">
</span><span class="k">Definition</span><span class="w"> </span><span class="no">latest_estimates_driven</span><span class="w"> </span><span class="o">(</span><span class="no">estimator</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">state</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">C</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kr">Prop</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Prop</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
    </span><span class="kp">exists</span><span class="w"> </span><span class="no">validator</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="o">(</span><span class="no">V</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">C</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">C</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kr">Prop</span><span class="o">,</span><span class="w">
      </span><span class="kr">forall</span><span class="w"> </span><span class="no">sigma</span><span class="w"> </span><span class="no">c</span><span class="o">,</span><span class="w"> </span><span class="no">estimator</span><span class="w"> </span><span class="no">sigma</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="o">&lt;-&gt;</span><span class="w"> </span><span class="no">validator</span><span class="w"> </span><span class="o">(</span><span class="no">latest_estimates</span><span class="w"> </span><span class="no">sigma</span><span class="o">)</span><span class="w"> </span><span class="no">c</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p><strong>Upshot</strong>: <code class="language-plaintext highlighter-rouge">latest_estimates_driven</code> <em>says there is a validator with knowledge of the latest estimates which is consistent with the estimator</em></p>

<p>The <code class="language-plaintext highlighter-rouge">in_fn</code> stands for ``in function‚Äô‚Äô which simply checks if the term <code class="language-plaintext highlighter-rouge">a : A</code> is in the list <code class="language-plaintext highlighter-rouge">l : list A</code> and returns a boolean value.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">in_fn</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="p">:</span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">eq_dec</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">,</span><span class="w"> </span><span class="o">{</span><span class="no">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">y</span><span class="o">}</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">{</span><span class="no">x</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="no">y</span><span class="o">})</span><span class="w"> </span><span class="o">(</span><span class="no">a</span><span class="p">:</span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">l</span><span class="p">:</span><span class="no">list</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">bool</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">match</span><span class="w"> </span><span class="no">in_dec</span><span class="w"> </span><span class="no">eq_dec</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="no">l</span><span class="w"> </span><span class="kp">with</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">left</span><span class="w"> </span><span class="p">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">true</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">right</span><span class="w"> </span><span class="p">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">false</span><span class="w">
  </span><span class="kr">end</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">validators_latest_estimate</code> function returns the list of validators from a state, whose last estimate contains the given consensus value <code class="language-plaintext highlighter-rouge">c</code>.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">validators_latest_estimates</span><span class="w"> </span><span class="o">(</span><span class="no">c</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">C</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">sigma</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">state</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">V</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
    </span><span class="no">filter</span><span class="w"> </span><span class="o">(</span><span class="kr">fun</span><span class="w"> </span><span class="no">v</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">in_fn</span><span class="w"> </span><span class="no">compare_eq_dec</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="o">(</span><span class="no">latest_estimates</span><span class="w"> </span><span class="no">sigma</span><span class="w"> </span><span class="no">v</span><span class="o">))</span><span class="w"> </span><span class="o">(</span><span class="no">observed</span><span class="w"> </span><span class="no">sigma</span><span class="o">).</span><span class="w">
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">score</code> of a consensus value <code class="language-plaintext highlighter-rouge">c</code> over a state <code class="language-plaintext highlighter-rouge">sigma</code> computes for the weight of the validators who have <code class="language-plaintext highlighter-rouge">c</code> in their latest estimates of the consensus values.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">score</span><span class="w"> </span><span class="o">(</span><span class="no">c</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">C</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">sigma</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">state</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">R</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
    </span><span class="no">fold_right</span><span class="w"> </span><span class="no">Rplus</span><span class="w"> </span><span class="no">R0</span><span class="w"> </span><span class="o">(</span><span class="no">map</span><span class="w"> </span><span class="no">posR_proj1</span><span class="w"> </span><span class="o">(</span><span class="no">map</span><span class="w"> </span><span class="no">weight</span><span class="w"> </span><span class="o">(</span><span class="no">validators_latest_estimates</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="no">sigma</span><span class="o">))).</span><span class="w">
</span></code></pre></div></div>

<p>My thoughts about <code class="language-plaintext highlighter-rouge">score</code> is that it could have been defined using the <code class="language-plaintext highlighter-rouge">sum_weights</code> function defined earlier:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">score'</span><span class="w"> </span><span class="o">(</span><span class="no">c</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">C</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">sigma</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">state</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">R</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="no">sum_weights</span><span class="w"> </span><span class="o">(</span><span class="no">validators_latest_estimates</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="no">sigma</span><span class="o">)</span><span class="w">
</span></code></pre></div></div>

<p>This leaves us at line 152 of <code class="language-plaintext highlighter-rouge">Binary.v</code> out of the total 489 lines.
In <a href="">Part 3</a>, we will be looking at <code class="language-plaintext highlighter-rouge">reach</code>, which are protocol state transitions.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>this is a valid estimator as all the consensus values are possible when no data is given.¬†<a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

  </article>

  
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_shortname  = 'zunction';
      var disqus_identifier = '/blog/2021/reading-casper-cbc-proofs-p2';
      var disqus_title      = "Reading Casper CBC proofs - Part 2";
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  

</div>

    </div>

    <!-- Footer -->

    
<footer class="fixed-bottom">
  <div class="container mt-0">
    &copy; Copyright 2021 Zhangsheng  Lai.
    
    
    
    Last updated: July 02, 2021.
    
  </div>
</footer>



  </body>

  <!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>

  
<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>


  


<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>


</html>
